// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rebuildeq.proto

#ifndef PROTOBUF_INCLUDED_rebuildeq_2eproto
#define PROTOBUF_INCLUDED_rebuildeq_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_rebuildeq_2eproto 

namespace protobuf_rebuildeq_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_rebuildeq_2eproto
namespace eqproto {
class Build;
class BuildDefaultTypeInternal;
extern BuildDefaultTypeInternal _Build_default_instance_;
class Builds;
class BuildsDefaultTypeInternal;
extern BuildsDefaultTypeInternal _Builds_default_instance_;
class Page;
class PageDefaultTypeInternal;
extern PageDefaultTypeInternal _Page_default_instance_;
class Pages;
class PagesDefaultTypeInternal;
extern PagesDefaultTypeInternal _Pages_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace eqproto
namespace google {
namespace protobuf {
template<> ::pb::Build* Arena::CreateMaybeMessage<::pb::Build>(Arena*);
template<> ::pb::Builds* Arena::CreateMaybeMessage<::pb::Builds>(Arena*);
template<> ::pb::Page* Arena::CreateMaybeMessage<::pb::Page>(Arena*);
template<> ::pb::Pages* Arena::CreateMaybeMessage<::pb::Pages>(Arena*);
template<> ::pb::User* Arena::CreateMaybeMessage<::pb::User>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace eqproto {

// ===================================================================

class User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eqproto.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(User* other);
  void Swap(User* other);
  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(NULL);
  }

  User* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  protected:
  explicit User(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 account_id = 1;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  ::google::protobuf::int64 account_id() const;
  void set_account_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:eqproto.User)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::int64 account_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rebuildeq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Build : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eqproto.Build) */ {
 public:
  Build();
  virtual ~Build();

  Build(const Build& from);

  inline Build& operator=(const Build& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Build(Build&& from) noexcept
    : Build() {
    *this = ::std::move(from);
  }

  inline Build& operator=(Build&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Build& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Build* internal_default_instance() {
    return reinterpret_cast<const Build*>(
               &_Build_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(Build* other);
  void Swap(Build* other);
  friend void swap(Build& a, Build& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Build* New() const final {
    return CreateMaybeMessage<Build>(NULL);
  }

  Build* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Build>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Build& from);
  void MergeFrom(const Build& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Build* other);
  protected:
  explicit Build(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_hash();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hash(
      ::std::string* hash);

  // @@protoc_insertion_point(class_scope:eqproto.Build)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rebuildeq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Builds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eqproto.Builds) */ {
 public:
  Builds();
  virtual ~Builds();

  Builds(const Builds& from);

  inline Builds& operator=(const Builds& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Builds(Builds&& from) noexcept
    : Builds() {
    *this = ::std::move(from);
  }

  inline Builds& operator=(Builds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Builds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Builds* internal_default_instance() {
    return reinterpret_cast<const Builds*>(
               &_Builds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Builds* other);
  void Swap(Builds* other);
  friend void swap(Builds& a, Builds& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Builds* New() const final {
    return CreateMaybeMessage<Builds>(NULL);
  }

  Builds* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Builds>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Builds& from);
  void MergeFrom(const Builds& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Builds* other);
  protected:
  explicit Builds(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .eqproto.Build builds = 1;
  int builds_size() const;
  void clear_builds();
  static const int kBuildsFieldNumber = 1;
  ::pb::Build* mutable_builds(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Build >*
      mutable_builds();
  const ::pb::Build& builds(int index) const;
  ::pb::Build* add_builds();
  const ::google::protobuf::RepeatedPtrField< ::pb::Build >&
      builds() const;

  // @@protoc_insertion_point(class_scope:eqproto.Builds)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::pb::Build > builds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rebuildeq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Page : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eqproto.Page) */ {
 public:
  Page();
  virtual ~Page();

  Page(const Page& from);

  inline Page& operator=(const Page& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Page(Page&& from) noexcept
    : Page() {
    *this = ::std::move(from);
  }

  inline Page& operator=(Page&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Page& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Page* internal_default_instance() {
    return reinterpret_cast<const Page*>(
               &_Page_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(Page* other);
  void Swap(Page* other);
  friend void swap(Page& a, Page& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Page* New() const final {
    return CreateMaybeMessage<Page>(NULL);
  }

  Page* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Page>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Page& from);
  void MergeFrom(const Page& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Page* other);
  protected:
  explicit Page(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 offset = 1;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // int64 limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  ::google::protobuf::int64 limit() const;
  void set_limit(::google::protobuf::int64 value);

  // int64 total = 3;
  void clear_total();
  static const int kTotalFieldNumber = 3;
  ::google::protobuf::int64 total() const;
  void set_total(::google::protobuf::int64 value);

  // int64 order_by = 4;
  void clear_order_by();
  static const int kOrderByFieldNumber = 4;
  ::google::protobuf::int64 order_by() const;
  void set_order_by(::google::protobuf::int64 value);

  // int64 is_descending = 5;
  void clear_is_descending();
  static const int kIsDescendingFieldNumber = 5;
  ::google::protobuf::int64 is_descending() const;
  void set_is_descending(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:eqproto.Page)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 limit_;
  ::google::protobuf::int64 total_;
  ::google::protobuf::int64 order_by_;
  ::google::protobuf::int64 is_descending_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rebuildeq_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pages : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eqproto.Pages) */ {
 public:
  Pages();
  virtual ~Pages();

  Pages(const Pages& from);

  inline Pages& operator=(const Pages& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pages(Pages&& from) noexcept
    : Pages() {
    *this = ::std::move(from);
  }

  inline Pages& operator=(Pages&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pages& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pages* internal_default_instance() {
    return reinterpret_cast<const Pages*>(
               &_Pages_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(Pages* other);
  void Swap(Pages* other);
  friend void swap(Pages& a, Pages& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pages* New() const final {
    return CreateMaybeMessage<Pages>(NULL);
  }

  Pages* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pages>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pages& from);
  void MergeFrom(const Pages& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pages* other);
  protected:
  explicit Pages(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .eqproto.Page pages = 1;
  int pages_size() const;
  void clear_pages();
  static const int kPagesFieldNumber = 1;
  ::pb::Page* mutable_pages(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Page >*
      mutable_pages();
  const ::pb::Page& pages(int index) const;
  ::pb::Page* add_pages();
  const ::google::protobuf::RepeatedPtrField< ::pb::Page >&
      pages() const;

  // @@protoc_insertion_point(class_scope:eqproto.Pages)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::pb::Page > pages_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_rebuildeq_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// int64 account_id = 1;
inline void User::clear_account_id() {
  account_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 User::account_id() const {
  // @@protoc_insertion_point(field_get:eqproto.User.account_id)
  return account_id_;
}
inline void User::set_account_id(::google::protobuf::int64 value) {
  
  account_id_ = value;
  // @@protoc_insertion_point(field_set:eqproto.User.account_id)
}

// -------------------------------------------------------------------

// Build

// string hash = 1;
inline void Build::clear_hash() {
  hash_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline const ::std::string& Build::hash() const {
  // @@protoc_insertion_point(field_get:eqproto.Build.hash)
  return hash_.Get();
}
inline void Build::set_hash(const ::std::string& value) {
  
  hash_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:eqproto.Build.hash)
}
#if LANG_CXX11
inline void Build::set_hash(::std::string&& value) {
  
  hash_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:eqproto.Build.hash)
}
#endif
inline void Build::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:eqproto.Build.hash)
}
inline void Build::set_hash(const char* value,
    size_t size) {
  
  hash_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:eqproto.Build.hash)
}
inline ::std::string* Build::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:eqproto.Build.hash)
  return hash_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* Build::release_hash() {
  // @@protoc_insertion_point(field_release:eqproto.Build.hash)
  
  return hash_.Release(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void Build::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:eqproto.Build.hash)
}
inline ::std::string* Build::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:eqproto.Build.hash)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  
  return hash_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void Build::unsafe_arena_set_allocated_hash(
    ::std::string* hash) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      hash, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:eqproto.Build.hash)
}

// -------------------------------------------------------------------

// Builds

// repeated .eqproto.Build builds = 1;
inline int Builds::builds_size() const {
  return builds_.size();
}
inline void Builds::clear_builds() {
  builds_.Clear();
}
inline ::pb::Build* Builds::mutable_builds(int index) {
  // @@protoc_insertion_point(field_mutable:eqproto.Builds.builds)
  return builds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Build >*
Builds::mutable_builds() {
  // @@protoc_insertion_point(field_mutable_list:eqproto.Builds.builds)
  return &builds_;
}
inline const ::pb::Build& Builds::builds(int index) const {
  // @@protoc_insertion_point(field_get:eqproto.Builds.builds)
  return builds_.Get(index);
}
inline ::pb::Build* Builds::add_builds() {
  // @@protoc_insertion_point(field_add:eqproto.Builds.builds)
  return builds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Build >&
Builds::builds() const {
  // @@protoc_insertion_point(field_list:eqproto.Builds.builds)
  return builds_;
}

// -------------------------------------------------------------------

// Page

// int64 offset = 1;
inline void Page::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Page::offset() const {
  // @@protoc_insertion_point(field_get:eqproto.Page.offset)
  return offset_;
}
inline void Page::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:eqproto.Page.offset)
}

// int64 limit = 2;
inline void Page::clear_limit() {
  limit_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Page::limit() const {
  // @@protoc_insertion_point(field_get:eqproto.Page.limit)
  return limit_;
}
inline void Page::set_limit(::google::protobuf::int64 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:eqproto.Page.limit)
}

// int64 total = 3;
inline void Page::clear_total() {
  total_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Page::total() const {
  // @@protoc_insertion_point(field_get:eqproto.Page.total)
  return total_;
}
inline void Page::set_total(::google::protobuf::int64 value) {
  
  total_ = value;
  // @@protoc_insertion_point(field_set:eqproto.Page.total)
}

// int64 order_by = 4;
inline void Page::clear_order_by() {
  order_by_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Page::order_by() const {
  // @@protoc_insertion_point(field_get:eqproto.Page.order_by)
  return order_by_;
}
inline void Page::set_order_by(::google::protobuf::int64 value) {
  
  order_by_ = value;
  // @@protoc_insertion_point(field_set:eqproto.Page.order_by)
}

// int64 is_descending = 5;
inline void Page::clear_is_descending() {
  is_descending_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Page::is_descending() const {
  // @@protoc_insertion_point(field_get:eqproto.Page.is_descending)
  return is_descending_;
}
inline void Page::set_is_descending(::google::protobuf::int64 value) {
  
  is_descending_ = value;
  // @@protoc_insertion_point(field_set:eqproto.Page.is_descending)
}

// -------------------------------------------------------------------

// Pages

// repeated .eqproto.Page pages = 1;
inline int Pages::pages_size() const {
  return pages_.size();
}
inline void Pages::clear_pages() {
  pages_.Clear();
}
inline ::pb::Page* Pages::mutable_pages(int index) {
  // @@protoc_insertion_point(field_mutable:eqproto.Pages.pages)
  return pages_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Page >*
Pages::mutable_pages() {
  // @@protoc_insertion_point(field_mutable_list:eqproto.Pages.pages)
  return &pages_;
}
inline const ::pb::Page& Pages::pages(int index) const {
  // @@protoc_insertion_point(field_get:eqproto.Pages.pages)
  return pages_.Get(index);
}
inline ::pb::Page* Pages::add_pages() {
  // @@protoc_insertion_point(field_add:eqproto.Pages.pages)
  return pages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Page >&
Pages::pages() const {
  // @@protoc_insertion_point(field_list:eqproto.Pages.pages)
  return pages_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace eqproto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_rebuildeq_2eproto
